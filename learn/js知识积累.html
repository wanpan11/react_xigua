<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <div>
        <button>111</button>
    </div>

    <button onmouseUp="btnClickHandler(event)">CLICK ME</button>


    <!-- 类基础 -->
    <!-- <script type="text/javascript">
        // 1.创建一个类
        class Wanpan {

            // 构造器方法
            constructor(a, b) {
                this.name = a
                this.age = b
            }

            size = {
                1: 1
            }

            // 实例方法 仅实例化对象才能访问
            say() {
                console.log(this.name + '今年' + this.age)
            }

            // 静态方法 static 会生成私有属性 实例化对象无法访问
            static staticFuc() {
                return '我是Wanpan的静态方法！';
            }

            static staticStr = '123';
        }

        const wanpan = new Wanpan('宛攀', 25)
        console.log(wanpan);
        wanpan.say();
        console.log(wanpan.staticStr);
        console.log(Wanpan.staticFuc());
        console.log(Wanpan.staticStr);

        // 1.1类的继承
        class Wanpan1 extends Wanpan {
            constructor(a, b, c) {
                //当前类如果继承与其他类 且需要构造器时 需要使用super()先调用父级构造器方法
                super(a, b)
                this.sex = c
            }
        }
        const wanpan1 = new Wanpan1('宛攀', 25, '男')

        // 1.创建一个类(函数)
        function Tanxiufen(a, b) {
            //这里实际返回的 init的实例对象
            return new Tanxiufen.prototype.init(a, b)
        }
        Tanxiufen.prototype = {
            constructor: Tanxiufen,
            init: function (a, b) {
                this.name = a
                this.age = b
            },
            say: function () {
                return console.log(this.name + '今年' + this.age)
            },
            age: '888'
        }
        //因为 new Tanxiufen() 时间返回的是init的实例 所有需要把init的prototype 修改为Tanxiufen的prototype 从而拥有say()方法
        Tanxiufen.prototype.init.prototype = Tanxiufen.prototype
        const tanxiufen = new Tanxiufen('谈秀芬', 24)


        // console.log(tanxiufen)
        // console.log(wanpan1)
        // wanpan.say()
        // tanxiufen.say()
    </script> -->
    <!-- <script>
        function Person() {
            this.name;
        }
        Person.prototype.say = function () {
            console.log("hello");
        }

        var person = new Person();

        console.log(Person.__proto__);
        console.log(Function.prototype);

        console.log(Person.prototype.__proto__);
        console.log(Object.prototype);

        console.log(person.__proto__);
        console.log(Person.prototype);

        console.log(Person.prototype.constructor);
        console.log(Person);
    </script> -->

    <!-- 事件冒泡 -->
    <!-- <script>
        const btn = document.getElementsByTagName('button')[0]
        const div = document.getElementsByTagName('div')[0]
        btn.addEventListener('click', (e) => {
            console.log(e.target);
            e.stopImmediatePropagation()
            e.stopPropagation()
        })
        div.addEventListener('click', (e) => {
            console.log(e.target);
        })
        div.addEventListener('mouseup', (e) => {
            console.log(e.target);
        })

        document.addEventListener("mouseup", function (event) {
            console.log("document clicked");
        }, false);
    
        function btnClickHandler(event) {
            // event.stopPropagation(); 
            console.log("btn clicked");
        }

    </script> -->

    <!-- Object -->
    <!-- <script>

        const o0 = new Object('宛攀')
        const o1 = new Object(111)


        console.log(o0, o1);

        const o2 = Object.prototype.toString.call(' 啥决斗链接')

        console.log(o2);


    </script> -->

    <!-- async await -->
    <script>

        async function test_1(params) {
            return params
        }

        /*  async function test() {
             let num = null
             await test_1(0).then(feed => {
                 console.log('#1', feed);
             }).then(() => {
                 num = 1
             })
             console.log('#2', num);
         } */

        async function test(params) {
            const num = await test_1(params)
            console.log('#2', num);
        }

        test(1)

        /* 
            Generator 函数
            Generator对象 像是一个方法集合 每个yield域 就是集合中的一个方法（子集们 被嵌套在一个公共方法里 所以每个子集都可以访问到其它子集的变量）
            每次调用next 方法就是执行下一个 yield域里的方法
        */
        function* mengmeng() {
            let a = yield 0
            let b = yield a
            yield b
        }

        const fun = mengmeng(1) //创建Generator 对象
        // console.log(fun.next())
        // console.log(fun.next(1))
        // console.log(fun.next(2))


        const getRawType = (target) => Object.prototype.toString.call(target).slice(8, -1);

        const __createArrayIterable = (arr) => {
            if (typeof Symbol !== 'function' || !Symbol.iterator) return {};
            if (getRawType(arr) !== 'Array') throw new Error('it must be Array');
            const iterable = {};
            iterable[Symbol.iterator] = () => {
                arr.length++;
                const iterator = {
                    next: () => ({ value: arr.shift(), done: arr.length <= 0 })
                }
                return iterator;
            };
            return iterable;
        };

        const itable = __createArrayIterable(['人月', '神话']);
        const it = itable[Symbol.iterator]();

        console.log(it.next()); // { value: "人月", done: false }
        console.log(it.next()); // { value: "神话", done: false }
        console.log(it.next()); // {value: undefined, done: true }

    </script>

</body>

</html>